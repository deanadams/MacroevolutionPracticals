tree<-read.tree("../data/anole.svl.tre",tree.names=T)
cont_data<-read.csv('../data/anole.svl.csv', row.names=1)
cont_data_vect<-setNames(cont_data$svl,rownames(cont_data)) ##contMap needs a named vector for the data.
cont_data
SVL<-read.csv('../data/anole.svl.csv', row.names=1)
#Data from Mahler et al. 2010. Evolution
tree<-read.tree("../data/anole.svl.tre",tree.names=T)
SVL<-read.csv('../data/anole.svl.csv', row.names=1)
phylosig(tree,SVL, method = "K")
dim(SVL)
SVL
tree$tip.label
phylosig(tree,SVL)
tree$edge.length
#Read Data from Mahler et al. 2010. Evolution
tree<-read.tree("../data/anole.svl.tre",tree.names=T)
SVL<-read.csv('../data/anole.svl.csv', row.names=1)
geomorph:::physignal(SVL, tree)
geomorph:::physignal.z(SVL, tree)
#Read Data from Mahler et al. 2010. Evolution
tree<-read.tree("../data/anole.svl.tre",tree.names=T)
cont_data<-read.csv('../data/anole.svl.csv', row.names=1)
#Read Data from Mahler et al. 2010. Evolution
tree<-read.tree("../data/anole.svl.tre",tree.names=T)
cont_data<-read.csv('../data/anole.svl.csv', row.names=1)
setwd("C:/DeanData/Teaching/Biol-465-EEOB 565-Macroevolution/MacroevolutionPracticals/08-Ancestral_States_PhySignal/scripts")
#Read Data from Mahler et al. 2010. Evolution
tree<-read.tree("../data/anole.svl.tre",tree.names=T)
cont_data<-read.csv('../data/anole.svl.csv', row.names=1)
SVL<-read.csv('../data/anole.svl.csv', row.names=1)
SVL$svl
SVL<-setNames(SVL$svl,rownames(SVL)) ##contMap needs a named vector for the data.
SVL
# Run phylogenetic signal
phylosig(tree,SVL)
geomorph:::physignal(SVL, tree)
physignal(SVL, tree)
library(geomorph)
physignal(SVL, tree) # same in geomorph
# Run phylogenetic signal
phylosig(tree,SVL,test = "K")
?phylosig
# Run phylogenetic signal
phylosig(tree,SVL,method = "K", test = TRUE)
physignal(SVL, tree) # same in geomorph
geomorph:::physignal.z(SVL, tree)
# Run phylogenetic signal
phylosig(tree,SVL,method = "lambda", test = TRUE)
setwd("C:/DeanData/Teaching/Biol-465-EEOB 565-Macroevolution/Josh-Additional-PracticalMaterials/09-Phylo_Assoc_Discrete/scripts")
## ----read_data----
library(geiger, warn.conflicts=F, quietly=T)
library(phytools, warn.conflicts=F, quietly=T)
library(corHMM, warn.conflicts=F, quietly=T)
tree<-read.tree("../data/tree.64.tre",tree.names=T)
mydata<-read.csv('../data/DiscreteData.csv', stringsAsFactors = TRUE, row.names=1, header=TRUE)
head(mydata) ##Head can be used to show the first few rows of a data frame
mydata$V1
mydata<-read.csv('../data/DiscreteData.csv', row.names=1, header=TRUE)
plotTree.datamatrix
data <- mydata[,1:2]
data
object <- plotTree.datamatrix(tree, data, fsize = 0.5, yexp = 1,
header = FALSE, xexp = 1.45, palettes = c("YlOrRd","PuBuGn") )
data <- mydata[,1:2]; data[,1] <- as.factor(data[,1]); data[,2] <- as.factor(data[,2])
data
object <- plotTree.datamatrix(tree, data, fsize = 0.5, yexp = 1,
header = FALSE, xexp = 1.45, palettes = c("YlOrRd","PuBuGn") )
data <- mydata[,c(1,3)]; data[,1] <- as.factor(data[,1]); data[,2] <- as.factor(data[,2])
data
object <- plotTree.datamatrix(tree, data, fsize = 0.5, yexp = 1,
header = FALSE, xexp = 1.45, palettes = c("YlOrRd","PuBuGn") )
leg <- legend(x = leg$rect$left + 4.7, y = leg$rect$top-leg$rect$h,
names(object$colors$V3), cex = 0.7,
pch = 22, pt.bg = object$colors$V3,
pt.cex = 1.5, bty = "n", title = "V3")
leg <- legend(x = "topright", names(object$colors$V1),
cex = 0.7, pch = 22, pt.bg = object$colors$V1,
pt.cex = 1.5, bty = "n", title = "V1")
leg <- legend(x = leg$rect$left + 4.7, y = leg$rect$top-leg$rect$h,
names(object$colors$V3), cex = 0.7,
pch = 22, pt.bg = object$colors$V3,
pt.cex = 1.5, bty = "n", title = "V3")
object <- plotTree.datamatrix(tree, data, fsize = 0.5, yexp = 1,
header = FALSE, xexp = 1.45, palettes = c("YlOrRd","PuBuGn") )
leg <- legend(x = "topright", names(object$colors$V1),
cex = 0.7, pch = 22, pt.bg = object$colors$V1,
pt.cex = 1.5, bty = "n", title = "V1")
leg <- legend(x = leg$rect$left + 2.7, y = leg$rect$top-leg$rect$h,
names(object$colors$V3), cex = 0.7,
pch = 22, pt.bg = object$colors$V3,
pt.cex = 1.5, bty = "n", title = "V3")
leg <- legend(x = leg$rect$left, y = leg$rect$top-leg$rect$h,
names(object$colors$V3), cex = 0.7,
pch = 22, pt.bg = object$colors$V3,
pt.cex = 1.5, bty = "n", title = "V3")
leg <- legend(x = "topright", y = leg$rect$top-leg$rect$h,
names(object$colors$V3), cex = 0.7,
pch = 22, pt.bg = object$colors$V3,
pt.cex = 1.5, bty = "n", title = "V3")
leg$rect$left
object <- plotTree.datamatrix(tree, data, fsize = 0.5, yexp = 1,
header = FALSE, xexp = 1.45, palettes = c("YlOrRd","PuBuGn") )
leg <- legend(x = "topright"-2, names(object$colors$V1),
cex = 0.7, pch = 22, pt.bg = object$colors$V1,
pt.cex = 1.5, bty = "n", title = "V1")
leg <- legend(x = "topright", names(object$colors$V1),
cex = 0.7, pch = 22, pt.bg = object$colors$V1,
pt.cex = 1.5, bty = "n", title = "V1")
dev.off()
object <- plotTree.datamatrix(tree, data, fsize = 0.5, yexp = 1,
header = FALSE, xexp = 1.45, palettes = c("YlOrRd","PuBuGn") )
leg <- legend(x = "topright", names(object$colors$V1),
cex = 0.7, pch = 22, pt.bg = object$colors$V1,
pt.cex = 1.5, bty = "n", title = "V1")
leg <- legend(x = leg$rect$left+ 4.7, y = leg$rect$top-leg$rect$h,
names(object$colors$V3), cex = 0.7,
pch = 22, pt.bg = object$colors$V3,
pt.cex = 1.5, bty = "n", title = "V3")
leg$rect$top
leg$rect$h
## ----read_data----
library(geiger, warn.conflicts=F, quietly=T)
library(phytools, warn.conflicts=F, quietly=T)
library(corHMM, warn.conflicts=F, quietly=T)
tree<-read.tree("../data/tree.64.tre",tree.names=T)
mydata<-read.csv('../data/DiscreteData.csv', row.names=1, header=TRUE)
head(mydata) ##Head can be used to show the first few rows of a data frame
#Match data with tree
data.pruned<-treedata(phy=tree,data = mydata, warnings=FALSE)
tree<-data.pruned$phy
mydata<-data.pruned$data
## NOTE: see `plotTree.datamatrix` in phytools for other plotting option
plot.phylo(tree,show.tip.label = F) ## setting show.tip.label = F prevents the species names from appearing
## We make a colour key to denote which state gets which color
colorkey1 <- c('red','black') ##trait V1
colorkey2 <- c('green','orange') ##trait V3
names(colorkey1) <-c(0,1) ##Here we are saying that 0s get red and 1s get black
names(colorkey2) <-c(0,1) ##Here we are saying that 0s get green and 1s get orange
V1cols<-colorkey1[as.character(mydata[,1])] ##putting the trait values in as.character() is important!
V3cols<-colorkey2[as.character(mydata[,3])]
tiplabels(pch = 17,col = V1cols,cex=0.6)
tiplabels(pch = 19,col = V3cols,offset = 0.2,cex=0.6)
plot.phylo(tree,show.tip.label = F)
tiplabels(pch = 17,col = V1cols)
#Set up data. corHMM is picky about how it wants the data formatted
trt1<-cbind(row.names(mydata),mydata[,1])
#Set up initial rate matrices
trait1_model_er <- getStateMat4Dat(trt1,"ER")  #equal transition rates
trait1_model_ard <- getStateMat4Dat(trt1,"ARD")  #All rates different
## ----single_trait_plot
trait1_model_er
trait1_model_ard
plotMKmodel(trait1_model_er$rate.mat,rate.cat = 1)
plotMKmodel(trait1_model_ard$rate.mat,rate.cat = 1)
#Fit models: TRAIT 1
trait1_fit_er <-corHMM(phy = tree, data = trt1, rate.cat = 1, rate.mat = trait1_model_er$rate.mat)
trait1_fit_ard <-corHMM(phy = tree, data = trt1, rate.cat = 1, rate.mat = trait1_model_ard$rate.mat)
##The estimated rates
trait1_fit_er$solution
trait1_fit_ard$solution
#compare models: logL and AIC
trait1_fit_er$loglik
trait1_fit_ard$loglik
##We can formally perform a likelihood ratio test of nested models by doing the following
summary_stat <- -2 * (trait1_fit_er$loglik - trait1_fit_ard$loglik) ## -2 * (model_constrained - model_full)
##This is our p-value
pchisq(summary_stat,df = 1,lower.tail=FALSE ) ##degrees of freedom is the difference in the number of parameters between the two models. In our case 2-1=1
trait1_fit_er$AIC
trait1_fit_ard$AIC
##first plot the data
V1cols<-colorkey1[as.character(mydata[,1])] ##putting the trait values in as.character() is important!
V2cols<-colorkey2[as.character(mydata[,2])]
plot(tree,show.tip.label = F)
tiplabels(pch = 17,col = V1cols)
tiplabels(pch = 19,col = V2cols,offset = 0.2)
##we set up the same format of data frame as before but now we include two traits: trait 1 and trait 2
trtset12<-cbind(row.names(mydata),mydata[,1:2])
trait12_model_er <- getStateMat4Dat(trtset12,"ER")  #equal transition rates
trait12_model_ard <- getStateMat4Dat(trtset12,"ARD")  #All rates different
trait12_model_er
trait12_model_ard
##coax the full transition matrix by having a data frame with all trait combinations
## First get all the unique states for the traits in question
states1<-unique(mydata[,1])
states2<-unique(mydata[,2])
traits12_expanded<-expand.grid('species',states1,states2) ##Having some string at the beginning is important! Our data needs the first column to be populated with names, this achieves that
##try making matrices again
trait12_model_er <- getStateMat4Dat(traits12_expanded,"ER")  #equal transition rates
trait12_model_ard <- getStateMat4Dat(traits12_expanded,"ARD")  #All rates different
traits12_expanded
##try making matrices again
trait12_model_er <- getStateMat4Dat(traits12_expanded,"ER")  #equal transition rates
trait12_model_ard <- getStateMat4Dat(traits12_expanded,"ARD")  #All rates different
##The full transition matrix. Hot dog!
trait12_model_er
trait12_model_ard
plotMKmodel(trait12_model_er$rate.mat,rate.cat = 1)
plotMKmodel(trait12_model_ard$rate.mat,rate.cat = 1)
## ----two_trait_pagel-----
tr1<-mydata[,1]; names(tr1)<-row.names(mydata)
tr2<-mydata[,2]; names(tr2)<-row.names(mydata)
pagel_fit <- fitPagel(tree,x=tr1,y=tr2)
pagel_fit
## ---- x_dep_y_fit ----
fitPagel(tree,x=tr1,y=tr2,dep.var = "x")
## ---- y_dep_x_fit ----
fitPagel(tree,x=tr1,y=tr2,dep.var = "y")
trait_model_er <- getStateMat4Dat(traits12_expanded,"ER")  #Transition matrix with equal transition rates for to two binary traits
##We will use the ER transition matrix as a starting point for our directional model
trait_model_dir<-trait_model_er
##Give some of the transitions their own rate
trait_model_dir$rate.mat[1,2]<-2
trait_model_dir$rate.mat[3,4]<-3
trait_model_dir
#Two trait analysis: Order to transitions matters (changes in trait 2 DEPEND on values of trait 1: Maddison 1990)
#Must define the two models for comparison
plot.phylo(tree,show.tip.label = F)
tiplabels(pie = to.matrix(mydata[,3],sort(unique(mydata[,3]))),piecol=c("red", "black"),cex=.3, offset=0)
tiplabels(pie = to.matrix(mydata[,4],sort(unique(mydata[,4]))),piecol=c("green", "orange"),cex=.3, offset=0.2)
traits34<-cbind(row.names(mydata),mydata[,3:4])
trait34_fit_er  <-corHMM(phy = tree, data = traits34, rate.cat = 1, rate.mat = trait_model_er$rate.mat)
trait34_fit_dir <-corHMM(phy = tree, data = traits34, rate.cat = 1, rate.mat = trait_model_dir$rate.mat)
trait34_fit_er$loglik
trait34_fit_dir$loglik
## ----read_data----
library(geiger, warn.conflicts=F, quietly=T)
library(phytools, warn.conflicts=F, quietly=T)
library(corHMM, warn.conflicts=F, quietly=T)
tree<-read.tree("../data/tree.64.tre",tree.names=T)
mydata<-read.csv('../data/DiscreteData.csv', row.names=1, header=TRUE)
head(mydata) ##Head can be used to show the first few rows of a data frame
plot(tree)
tree
match(tree$tip.label,rownames(mydata))
match(tree$tip.label,sample(rownames(mydata)))
#Match data with tree
data.pruned<-treedata(phy=tree,data = mydata, warnings=FALSE)
tree<-data.pruned$phy
mydata<-data.pruned$data
## NOTE: see `plotTree.datamatrix` in phytools for other plotting option
plot.phylo(tree,show.tip.label = F) ## setting show.tip.label = F prevents the species names from appearing
## We make a colour key to denote which state gets which color
colorkey1 <- c('red','black') ##trait V1
colorkey2 <- c('green','orange') ##trait V3
names(colorkey1) <-c(0,1) ##Here we are saying that 0s get red and 1s get black
names(colorkey2) <-c(0,1) ##Here we are saying that 0s get green and 1s get orange
V1cols<-colorkey1[as.character(mydata[,1])] ##putting the trait values in as.character() is important!
V3cols<-colorkey2[as.character(mydata[,3])]
tiplabels(pch = 17,col = V1cols,cex=0.6)
tiplabels(pch = 19,col = V3cols,offset = 0.2,cex=0.6)
View(mydata)
plot.phylo(tree,show.tip.label = F)
tiplabels(pch = 17,col = V1cols)
#Set up data. corHMM is picky about how it wants the data formatted
trt1<-cbind(row.names(mydata),mydata[,1])
#Set up initial rate matrices
trait1_model_er <- getStateMat4Dat(trt1,"ER")  #equal transition rates
trait1_model_ard <- getStateMat4Dat(trt1,"ARD")  #All rates different
## ----single_trait_plot
trait1_model_er
trait1_model_ard
plotMKmodel(trait1_model_er$rate.mat,rate.cat = 1)
plotMKmodel(trait1_model_ard$rate.mat,rate.cat = 1)
#Fit models: TRAIT 1
trait1_fit_er <-corHMM(phy = tree, data = trt1, rate.cat = 1,
rate.mat = trait1_model_er$rate.mat)
trait1_fit_ard <-corHMM(phy = tree, data = trt1, rate.cat = 1,
rate.mat = trait1_model_ard$rate.mat)
##The estimated rates
trait1_fit_er$solution
trait1_fit_ard$solution
#compare models: logL and AIC
trait1_fit_er$loglik
trait1_fit_ard$loglik
##We can formally perform a likelihood ratio test of nested models by doing the following
summary_stat <- -2 * (trait1_fit_er$loglik - trait1_fit_ard$loglik) ## -2 * (model_constrained - model_full)
##This is our p-value
pchisq(summary_stat,df = 1,lower.tail=FALSE ) ##degrees of freedom is the difference in the number of parameters between the two models. In our case 2-1=1
trait1_fit_er$AIC
trait1_fit_ard$AIC
##first plot the data
V1cols<-colorkey1[as.character(mydata[,1])] ##putting the trait values in as.character() is important!
V2cols<-colorkey2[as.character(mydata[,2])]
plot(tree,show.tip.label = F)
tiplabels(pch = 17,col = V1cols)
tiplabels(pch = 19,col = V2cols,offset = 0.2)
##we set up the same format of data frame as before but now we include two traits: trait 1 and trait 2
trtset12<-cbind(row.names(mydata),mydata[,1:2])
trait12_model_er <- getStateMat4Dat(trtset12,"ER")  #equal transition rates
trait12_model_ard <- getStateMat4Dat(trtset12,"ARD")  #All rates different
trait12_model_er
trait12_model_ard
##coax the full transition matrix by having a data frame with all trait combinations
## First get all the unique states for the traits in question
states1<-unique(mydata[,1])
states2<-unique(mydata[,2])
traits12_expanded<-expand.grid('species',states1,states2) ##Having some string at the beginning is important! Our data needs the first column to be populated with names, this achieves that
##try making matrices again
trait12_model_er <- getStateMat4Dat(traits12_expanded,"ER")  #equal transition rates
trait12_model_ard <- getStateMat4Dat(traits12_expanded,"ARD")  #All rates different
##The full transition matrix. Hot dog!
trait12_model_er
trait12_model_ard
##coax the full transition matrix by having a data frame with all trait combinations
## First get all the unique states for the traits in question
states1<-unique(mydata[,1])
states2<-unique(mydata[,2])
traits12_expanded<-expand.grid('species',states1,states2) ##Having some string at the beginning is important! Our data needs the first column to be populated with names, this achieves that
##try making matrices again
trait12_model_er <- getStateMat4Dat(traits12_expanded,"ER")  #equal transition rates
trait12_model_ard <- getStateMat4Dat(traits12_expanded,"ARD")  #All rates different
##The full transition matrix. Hot dog!
trait12_model_er
trait12_model_ard
plotMKmodel(trait12_model_er$rate.mat,rate.cat = 1)
plotMKmodel(trait12_model_ard$rate.mat,rate.cat = 1)
## ----two_trait_pagel-----
tr1<-mydata[,1]; names(tr1)<-row.names(mydata)
tr2<-mydata[,2]; names(tr2)<-row.names(mydata)
pagel_fit <- fitPagel(tree,x=tr1,y=tr2)
pagel_fit
## ---- x_dep_y_fit ----
fitPagel(tree,x=tr1,y=tr2,dep.var = "x")
## ---- y_dep_x_fit ----
fitPagel(tree,x=tr1,y=tr2,dep.var = "y")
## ----read_data----
library(geiger, warn.conflicts=F, quietly=T)
library(phytools, warn.conflicts=F, quietly=T)
library(corHMM, warn.conflicts=F, quietly=T)
tree<-read.tree("../data/tree.64.tre",tree.names=T)
mydata<-read.csv('../data/DiscreteData.csv', row.names=1, header=TRUE)
head(mydata) ##Head can be used to show the first few rows of a data frame
#Match data with tree
data.pruned<-treedata(phy=tree,data = mydata, warnings=FALSE)
tree<-data.pruned$phy
mydata<-data.pruned$data
## NOTE: see `plotTree.datamatrix` in phytools for other plotting option
plot.phylo(tree,show.tip.label = F) ## setting show.tip.label = F prevents the species names from appearing
## We make a colour key to denote which state gets which color
colorkey1 <- c('red','black') ##trait V1
colorkey2 <- c('green','orange') ##trait V3
names(colorkey1) <-c(0,1) ##Here we are saying that 0s get red and 1s get black
names(colorkey2) <-c(0,1) ##Here we are saying that 0s get green and 1s get orange
V1cols<-colorkey1[as.character(mydata[,1])] ##putting the trait values in as.character() is important!
V3cols<-colorkey2[as.character(mydata[,3])]
tiplabels(pch = 17,col = V1cols,cex=0.6)
tiplabels(pch = 19,col = V3cols,offset = 0.2,cex=0.6)
plot.phylo(tree,show.tip.label = F)
tiplabels(pch = 17,col = V1cols)
#Set up data. corHMM is picky about how it wants the data formatted
trt1<-cbind(row.names(mydata),mydata[,1])
#Set up initial rate matrices
trait1_model_er <- getStateMat4Dat(trt1,"ER")  #equal transition rates
trait1_model_ard <- getStateMat4Dat(trt1,"ARD")  #All rates different
## ----single_trait_plot
trait1_model_er
trait1_model_ard
plotMKmodel(trait1_model_er$rate.mat,rate.cat = 1)
plotMKmodel(trait1_model_ard$rate.mat,rate.cat = 1)
#Fit models: TRAIT 1
trait1_fit_er <-corHMM(phy = tree, data = trt1, rate.cat = 1, rate.mat = trait1_model_er$rate.mat)
trait1_fit_ard <-corHMM(phy = tree, data = trt1, rate.cat = 1, rate.mat = trait1_model_ard$rate.mat)
##The estimated rates
trait1_fit_er$solution
trait1_fit_ard$solution
#compare models: logL and AIC
trait1_fit_er$loglik
trait1_fit_ard$loglik
##We can formally perform a likelihood ratio test of nested models by doing the following
summary_stat <- -2 * (trait1_fit_er$loglik - trait1_fit_ard$loglik) ## -2 * (model_constrained - model_full)
##This is our p-value
pchisq(summary_stat,df = 1,lower.tail=FALSE ) ##degrees of freedom is the difference in the number of parameters between the two models. In our case 2-1=1
trait1_fit_er$AIC
trait1_fit_ard$AIC
##first plot the data
V1cols<-colorkey1[as.character(mydata[,1])] ##putting the trait values in as.character() is important!
V2cols<-colorkey2[as.character(mydata[,2])]
plot(tree,show.tip.label = F)
tiplabels(pch = 17,col = V1cols)
tiplabels(pch = 19,col = V2cols,offset = 0.2)
##coax the full transition matrix by having a data frame with all trait combinations
## First get all the unique states for the traits in question
states1<-unique(mydata[,1])
states2<-unique(mydata[,2])
traits12_expanded<-expand.grid('species',states1,states2) ##Having some string at the beginning is important! Our data needs the first column to be populated with names, this achieves that
##try making matrices again
trait12_model_er <- getStateMat4Dat(traits12_expanded,"ER")  #equal transition rates
trait12_model_ard <- getStateMat4Dat(traits12_expanded,"ARD")  #All rates different
##The full transition matrix. Hot dog!
trait12_model_er
trait12_model_ard
plotMKmodel(trait12_model_er$rate.mat,rate.cat = 1)
plotMKmodel(trait12_model_ard$rate.mat,rate.cat = 1)
## ----two_trait_pagel-----
tr1<-mydata[,1]; names(tr1)<-row.names(mydata)
tr2<-mydata[,2]; names(tr2)<-row.names(mydata)
pagel_fit <- fitPagel(tree,x=tr1,y=tr2)
pagel_fit
## ---- x_dep_y_fit ----
fitPagel(tree,x=tr1,y=tr2,dep.var = "x")
## ---- y_dep_x_fit ----
fitPagel(tree,x=tr1,y=tr2,dep.var = "y")
trait_model_er <- getStateMat4Dat(traits12_expanded,"ER")  #Transition matrix with equal transition rates for to two binary traits
##We will use the ER transition matrix as a starting point for our directional model
trait_model_dir<-trait_model_er
##Give some of the transitions their own rate
trait_model_dir$rate.mat[1,2]<-2
trait_model_dir$rate.mat[3,4]<-3
trait_model_dir
#Two trait analysis: Order to transitions matters (changes in trait 2 DEPEND on values of trait 1: Maddison 1990)
#Must define the two models for comparison
plot.phylo(tree,show.tip.label = F)
tiplabels(pie = to.matrix(mydata[,3],sort(unique(mydata[,3]))),piecol=c("red", "black"),cex=.3, offset=0)
tiplabels(pie = to.matrix(mydata[,4],sort(unique(mydata[,4]))),piecol=c("green", "orange"),cex=.3, offset=0.2)
traits34<-cbind(row.names(mydata),mydata[,3:4])
trait34_fit_er  <-corHMM(phy = tree, data = traits34, rate.cat = 1, rate.mat = trait_model_er$rate.mat)
trait34_fit_dir <-corHMM(phy = tree, data = traits34, rate.cat = 1, rate.mat = trait_model_dir$rate.mat)
trait34_fit_er$loglik
trait34_fit_dir$loglik
trait34_fit_er$AIC
trait34_fit_dir$AIC ##Strong preference for trait34_fit_dir
## ---- sim_problem -----
set.seed(6679881) ##The n for the largest known Cullen prime. Cullen primes have the form n*(2^n)+1
library(phytools)
#A quick simulation
mytree<- pbtree(n=50, scale=1) #one way to simulate a tree. Note: in R, one has functions to simulate BD trees, random splits trees, etc. using different functions
plot(mytree)
X<-fastBM(tree=mytree) #simulates a continuous trait on phylogeny under Brownian motion
Y<-fastBM(tree=mytree)
cor(X,Y)
X_pic <- pic(x=X,phy=mytree)
Y_pic <- pic(x=Y,phy=mytree)
cor(X_pic,Y_pic)
library(ape)
library(geiger)
#Here is a large time-dated molecular phylogeny (a chronogram):
ManderTree<-read.tree("../data/Mander.tre",tree.names=T)
setwd("C:/DeanData/Teaching/Biol-465-EEOB 565-Macroevolution/MacroevolutionPracticals/10-Phylo_Regression/scripts")
#Here is a large time-dated molecular phylogeny (a chronogram):
ManderTree<-read.tree("../data/Mander.tre",tree.names=T)
plot(ManderTree)
#Read in data, phylogeny, and match/prune them to one another
ManderTree<-read.tree("../data/Mander.tre",tree.names=T)
plot(ManderTree)
Mander_dat<-read.csv("../data/PlethodonMns.csv", header=TRUE, row.names = 1) #Notice we read in the first column as row.names. These MUST match the names in the phylogeny
Mander_dat[,12]<-(as.numeric(Mander_dat[,12]=="N")) ##Convert the groups from strings to numerics. Treedata doesn't like different types of data.
#Now, prune the tree to match the data and vice-versa:
Pleth_matched<-treedata(phy=ManderTree,data = Mander_dat,sort=T, warnings=FALSE)
plot(Pleth_matched$phy)
#grabs appropriate column from data matrix after treedata. We'll use these in analyses later
SVL<-Pleth_matched$data[,1]
HL<-Pleth_matched$data[,3]
BodyW<-Pleth_matched$data[,5]
Fore<-Pleth_matched$data[,6]
Hind<-Pleth_matched$data[,7]
Groups<-as.factor(Pleth_matched$data[,12]);names(Groups)<-rownames(Pleth_matched$data) ##Store the groups and name the vector according to the samples
#Now read in data for species in the genus Hydromantes
Hyd_dat<-read.csv("../data/HydromantesMns.csv", header=TRUE, row.names = 1)
Hyd_dat
Hydro_matched<-treedata(phy=ManderTree,data = Hyd_dat, warnings=FALSE)
plot(Hydro_matched$phy)  #We have matched data to the tree!
#Phylogenetically-naive analyses
plot(BodyW,Hind)
cor.test(Hind,BodyW)  #correlation of two traits: pretty high
anova(lm(Hind~BodyW))
#Generate PICs and test while conditioning on phylogeny
Hind_pic<-pic(x = Hind, phy = Pleth_matched$phy)
BodyW_pic<-pic(x = BodyW, phy = Pleth_matched$phy)
cor.test(Hind_pic,BodyW_pic)
plot(BodyW_pic,Hind_pic)
anova(lm(Hind_pic~BodyW_pic+0))   #regression through the origin (b/c order of taxa for contrast is arbitrary [can 'spin' on node])
summary(lm(Hind_pic~BodyW_pic+0))   #coefficients of the model
#To perform PGLS in R, we must first estimate the phylogenetic covariance matrix V (C in matrix form):
spc <- Pleth_matched$phy$tip.label
V<-corBrownian(phy=Pleth_matched$phy,form = ~spc)
C <- vcv.phylo(phy = Pleth_matched$phy)
#Now we run the analysis:
library(nlme)
bm_gls<-gls(HL~Hind,correlation = V, data=data.frame(Hind, HL))
summary(bm_gls)
anova(bm_gls)
library(RRPP)
##lm.rrpp, the function used to create the model, requires the data in a specific format. rrpp.data.frame puts the data in that format. It is essentially a data frame in a specific format.
rdf<-rrpp.data.frame(Hind=as.matrix(Hind),Fore=as.matrix(Fore),Groups=as.matrix(Groups), C=C)
res.PhyT<-lm.rrpp(Hind~Fore, data = rdf, Cov = C, print.progress = FALSE)
anova(res.PhyT)
res.PhyT$LM$gls.coefficients ## the estimated coefficients of the model
aov.phylo(SVL~Groups, phy = Pleth_matched$phy) ##Not the same analysis
## ---- phylo_ANOVA
anova(lm.rrpp(SVL~Groups, data = rdf, Cov = C, print.progress = FALSE))
anova(gls(SVL~Groups,correlation = V, data=data.frame(SVL, Groups)))  #identical to Phylo.transform
####Phylogenetic Signal
library(geomorph)
phylosig(tree=Pleth_matched$phy, x=SVL, method="K", test=T, nsim=1000)  #phytools
res<-physignal(A=SVL,phy = Pleth_matched$phy, print.progress = FALSE)   #geomorph
summary(res)  #the same, but the latter method (from geomorph) can accomodate multivariate data
plot(res)
## ---- OLS_cor_sim ----
####Additional Simulation Approaches
#Simulate correlated data
library(MASS)
R<-matrix(0.7, nrow=2,ncol=2); diag(R)<-1 ## This matrix desribes the covariation between traits
R
dat.sim<-mvrnorm(n=10000,Sigma = R,mu = c(0,0))
plot(dat.sim, asp=1)
## ---- Phylo_cor_sim ----
#Simulate BM correlated data on phylogeny
mytree<- pbtree(n=100, scale=1) #one way to simulate a tree
R<-matrix(0.7, nrow=2,ncol=2); diag(R)<-1 ## This matrix describes the covariation between traits
R
dat.BM<-sim.char(phy = mytree,par = R,nsim = 1)[,,1]
plot(dat.BM, asp=1)
